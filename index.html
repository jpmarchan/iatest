<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"El Inmortal" Asistente Legal de Voz STT y TTS Nativo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #eef2ff;
            /* Un azul claro muy suave */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            background-image: linear-gradient(to top right, #eef2ff, #f3f4f6);
        }

        .lucide {
            stroke-width: 2.5;
        }

        /* Animaci√≥n personalizada para el bot√≥n de grabaci√≥n */
        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            70% {
                box-shadow: 0 0 0 25px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .animate-pulse-red {
            animation: pulse-red 2s infinite;
        }

        /* Clase de animaci√≥n para el icono de voz activa */
        .speak-active {
            filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.8));
            animation: pulse-blue 1s infinite alternate;
        }

        @keyframes pulse-blue {
            from {
                opacity: 0.7;
            }

            to {
                opacity: 1;
            }
        }

        /* ESTILO PARA EL FONDO DEL CONTENEDOR PRINCIPAL */
        #voiceAssistantCard {
            /* Ruta de la imagen subida por el usuario */
            background-image:
                /* Degradado oscuro semi-transparente. */
                linear-gradient(rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.7)),
                /* Imagen de fondo. Asumo que 'profe.jpeg' est√° disponible. */
                url('profe.jpeg');

            /* PROPIEDADES CLAVE PARA LA SOLUCI√ìN */
            background-size: cover;
            /* Evita la deformaci√≥n, cubre el √°rea */
            background-position: center;
            /* FIN DE PROPIEDADES CLAVE */

            background-blend-mode: lighten;
            /* Mezcla el fondo blanco con la imagen */
            position: relative;
            z-index: 10;
        }

        /* Se remueve el fondo blanco directo para que la imagen sea visible a trav√©s del blend mode */
        #voiceAssistantCard.bg-white {
            background-color: transparent !important;
        }
    </style>
</head>

<body>

    <!-- Contenedor Principal con Estilo de Tarjeta Moderna -->
    <!-- Se mantiene la clase bg-white, pero se anula en CSS con !important para usar el background-image con blend-mode -->
    <div id="voiceAssistantCard"
        class="bg-white shadow-2xl rounded-2xl p-6 md:p-10 w-full max-w-xl transition-all duration-500 border-t-8 border-blue-600/70 backdrop-blur-sm">

        <!-- Header -->
        <div class="text-center mb-8">
            <i data-lucide="gavel" class="lucide w-12 h-12 text-blue-800 mx-auto mb-2"></i>
            <h1 class="text-3xl font-extrabold text-gray-900 leading-tight">"El Inmortal"</h1>
            <h2 class="text-xl font-semibold text-blue-700 mt-1">Asistente Legal</h2>
            <p class="text-sm text-gray-600 mt-2">Soluciones r√°pidas con STT y TTS nativo (Voz a Texto a Voz).</p>
        </div>

        <!-- √Årea de Usuario -->
        <div id="usernameDisplay"
            class="hidden text-base text-gray-700 mb-6 flex items-center justify-center bg-blue-50/70 p-3 rounded-xl border border-blue-200">
            <i data-lucide="user-check" class="lucide w-5 h-5 mr-2 text-green-600"></i> Usuario Activo: <span
                id="currentUsername" class="font-bold text-blue-800 ml-2"></span>
        </div>

        <!-- Formulario de Nombre -->
        <form id="nameForm" class="mt-4 mb-6 flex gap-3">
            <input id="nameInput" type="text" placeholder="Ingresa tu nombre para identificarte..." required
                class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-4 focus:ring-blue-200 focus:border-blue-500 transition duration-200 shadow-inner" />
            <button type="submit"
                class="bg-blue-600 text-white px-5 py-3 rounded-xl font-semibold hover:bg-blue-700 transition shadow-md hover:shadow-lg active:scale-95">
                <i data-lucide="send" class="lucide w-5 h-5"></i>
            </button>
        </form>

        <!-- √Årea de Estado -->
        <div id="statusArea"
            class="p-4 rounded-xl text-center font-semibold transition-colors duration-300 mb-6 min-h-[4.5rem] flex items-center justify-center shadow-inner">
            <p id="statusMessage" class="text-base leading-relaxed">Presiona el micr√≥fono para INICIAR la consulta.</p>
        </div>

        <!-- Transcripci√≥n mostrada (Consulta del Usuario) -->
        <div id="transcriptionBox"
            class="bg-blue-100/80 text-blue-900 p-4 rounded-xl text-sm mb-8 border border-blue-300 shadow-lg hidden">
            <span class="font-bold block mb-1">Tu consulta (Vista Previa):</span>
            <span id="transcriptionPreview" class="block italic text-gray-700"></span>
        </div>

        <!-- Controles de Voz -->
        <div class="flex justify-center">
            <!-- Bot√≥n de Iniciar/Detener (Toggle Mode) -->
            <button id="voiceToggleButton"
                class="p-7 rounded-full shadow-2xl transition-all duration-300 flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white w-24 h-24 disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-100"
                title="Presiona para INICIAR la grabaci√≥n" disabled>
                <!-- Icono de Micr√≥fono por defecto -->
                <i id="micIcon" data-lucide="mic" class="lucide w-10 h-10"></i>
                <!-- El icono de carga se mostrar√° en el estado 'loading' -->
                <i id="loaderIcon" data-lucide="loader-2" class="lucide w-10 h-10 animate-spin hidden"></i>
                <!-- El icono de detener se mostrar√° en el estado 'recording' -->
                <i id="stopIcon" data-lucide="square" class="lucide w-10 h-10 hidden"></i>
            </button>
        </div>

        <!-- Respuesta de Texto y TTS (Nuevo) -->
        <div id="responseContainer" class="mt-10 pt-5 border-t border-gray-300/50 hidden">
            <h3 class="text-lg font-bold text-gray-700 mb-3 flex items-center">
                <i id="voiceIcon" data-lucide="volume-2" class="lucide w-6 h-6 mr-3 text-blue-600"></i> Respuesta del
                Asesor IA
            </h3>
            <div id="responseText"
                class="bg-gray-100/70 p-4 rounded-xl text-sm border border-gray-200 shadow-inner text-gray-800 min-h-[6rem] whitespace-pre-wrap">
                <!-- El texto de la respuesta se insertar√° aqu√≠ -->
            </div>
        </div>

    </div>

    <script>
        // URL de tu endpoint de backend que recibe TEXTO y devuelve TEXTO JSON
        const TEXT_QUERY_URL = "https://06955aa06b28.ngrok-free.app/api/text_query";

        // El nombre de la propiedad en el JSON que contendr√° la respuesta de texto.
        const RESPONSE_TEXT_FIELD = "response_text";

        // === ESTADO GLOBAL ===
        const appState = {
            isRecording: false,
            isLoading: false,
            isSpeaking: false, // Nuevo estado para TTS
            transcriptionPreview: "",
            statusMessage: "Presiona el micr√≥fono para INICIAR la consulta.",
            username: "",
            hasSent: false, // Bandera para evitar doble env√≠o
            finalTranscript: "", // Para guardar la transcripci√≥n final m√°s reciente
            recognition: null, // Para STT
            utterance: null, // Para TTS
            ttsVoices: [], // Lista de voces cargadas
            // Referencias DOM
            dom: {
                statusArea: null,
                statusMessage: null,
                transcriptionBox: null,
                transcriptionPreview: null,
                voiceToggleButton: null,
                micIcon: null,
                loaderIcon: null,
                stopIcon: null,
                responseContainer: null,
                responseText: null,
                voiceIcon: null,
                nameForm: null,
                nameInput: null,
                usernameDisplay: null,
                currentUsername: null
            }
        };

        // === UTILIDADES INTERNAS ===

        /**
         * Selecciona una voz en espa√±ol que no sea la predeterminada (intenta ser masculina).
         * @returns {SpeechSynthesisVoice|null} La voz seleccionada o null si solo hay una o ninguna.
         */
        function getSpanishPreferredVoice() {
            const targetLangPrefix = 'es';
            // Nota: Usar window.speechSynthesis.getVoices() requiere que se haya cargado previamente.
            // Asumo que 'appState.ttsVoices' ya contiene las voces cargadas.
            const voices = appState.ttsVoices.length > 0 ? appState.ttsVoices : window.speechSynthesis.getVoices();

            // 1. Filtrar todas las voces en espa√±ol
            let spanishVoices = voices.filter(voice => voice.lang.startsWith(targetLangPrefix));

            if (spanishVoices.length === 0) {
                // No hay voces en espa√±ol disponibles
                console.warn("No se encontraron voces en espa√±ol.");
                return null;
            }

            // 2. Palabras clave masculinas reforzadas para aumentar la heur√≠stica
            // Se eliminan t√©rminos gen√©ricos ('google', 'microsoft', 'es-es', 'zira') que a menudo 
            // se usan en voces femeninas de alta calidad, y se priorizan t√©rminos de g√©nero y nombres.
            const maleKeywords = [
                'male', 'hombre', 'masculina', // Nuevos t√©rminos de g√©nero
                'jorge', 'juan', 'pablo', 'sergio', 'david',
                'daniel', 'diego', 'carlos', 'antonio', 'raul', // Nombres masculinos comunes a√±adidos
            ].map(k => k.toLowerCase()); // Convertir a min√∫sculas para la comparaci√≥n

            let selectedVoice = null;

            // 3. Buscar la primera voz que contenga una de las palabras clave masculinas
            // Hacemos una b√∫squeda m√°s exhaustiva.
            for (const voice of spanishVoices) {
                const voiceNameLower = voice.name.toLowerCase();
                const isMale = maleKeywords.some(keyword => voiceNameLower.includes(keyword));

                if (isMale) {
                    // ¬°Encontrada una voz que probablemente sea masculina!
                    selectedVoice = voice;
                    console.log(`Voz masculina seleccionada por heur√≠stica: ${voice.name}`);
                    break;
                }
            }

            // 4. Contingencia: Si no se encuentra una clave masculina, usar la primera voz disponible.
            // Esta es la voz por defecto del navegador para el idioma.
            if (!selectedVoice) {
                selectedVoice = spanishVoices[0];
                console.warn(`No se encontr√≥ una voz masculina espec√≠fica. Usando la voz por defecto: ${selectedVoice.name}`);
            }

            return selectedVoice;
        }

        /**
         * Actualiza el estado visual de la UI bas√°ndose en el estado global.
         */
        function updateUI() {
            const { isRecording, isLoading, isSpeaking, statusMessage, transcriptionPreview, username } = appState;
            const {
                statusArea, statusMessage: statusMsgEl, transcriptionBox, transcriptionPreview: transcriptPrevEl,
                voiceToggleButton, micIcon, loaderIcon, stopIcon,
                nameForm, usernameDisplay, currentUsername, voiceIcon, responseContainer
            } = appState.dom;

            // 1. Manejo del Usuario
            nameForm.classList.toggle('hidden', !!username);
            usernameDisplay.classList.toggle('hidden', !username);
            if (username) {
                currentUsername.textContent = username;
            }

            // Si no hay usuario, deshabilitar el bot√≥n principal y salir
            if (!username) {
                voiceToggleButton.disabled = true;
                statusMsgEl.textContent = "‚ùå Por favor, ingresa tu nombre antes de comenzar.";
                statusArea.className = 'p-4 rounded-xl text-center font-semibold transition-colors duration-300 mb-6 min-h-[4.5rem] flex items-center justify-center shadow-inner bg-red-100 text-red-800 border border-red-300';
                return;
            } else {
                // El bot√≥n solo se deshabilita si est√° cargando. Si est√° hablando, se permite hacer clic para CANCELAR.
                voiceToggleButton.disabled = isLoading || !appState.recognition;
            }

            // 2. Transcripci√≥n
            const showTranscription = !!transcriptionPreview;
            transcriptionBox.classList.toggle('hidden', !showTranscription);
            transcriptPrevEl.textContent = transcriptionPreview;

            // 3. √Årea de Estado y Mensaje
            statusMsgEl.textContent = statusMessage;

            // Limpiar clases de fondo del status area
            statusArea.className = 'p-4 rounded-xl text-center font-semibold transition-colors duration-300 mb-6 min-h-[4.5rem] flex items-center justify-center shadow-inner';

            let statusClasses = 'bg-gray-100/70 text-gray-700 border border-gray-300';
            const isError = statusMessage.includes('‚ùå') || statusMessage.includes('Error') || statusMessage.includes('‚ö†Ô∏è');

            if (isLoading) {
                statusClasses = 'bg-blue-100/80 text-blue-800 border border-blue-300';
            } else if (isRecording) {
                statusClasses = 'bg-red-100/80 text-red-800 border border-red-300';
            } else if (isError) {
                statusClasses = 'bg-red-100/80 text-red-800 border border-red-300';
            } else if (isSpeaking) {
                statusClasses = 'bg-green-100/80 text-green-800 border border-green-300';
            }
            statusArea.classList.add(...statusClasses.split(' '));

            // 4. Bot√≥n de Toggle y Iconos
            voiceToggleButton.classList.remove(
                'bg-red-600', 'hover:bg-red-700', 'animate-pulse-red', 'shadow-red-500/50',
                'bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50', 'bg-green-600', 'hover:bg-green-700'
            );

            micIcon.classList.add('hidden');
            loaderIcon.classList.add('hidden');
            stopIcon.classList.add('hidden');

            if (isLoading) {
                voiceToggleButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-xl', 'shadow-blue-500/50');
                voiceToggleButton.title = "Procesando...";
                loaderIcon.classList.remove('hidden');
            } else if (isSpeaking) {
                voiceToggleButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow-xl', 'shadow-green-500/50');
                voiceToggleButton.title = "Presiona para INTERRUMPIR y hacer una nueva consulta";
                // Usamos el mic como un icono de 'play/speak'
                micIcon.classList.remove('hidden');
                voiceIcon.classList.toggle('speak-active', true);
            } else if (isRecording) {
                voiceToggleButton.classList.add('bg-red-600', 'hover:bg-red-700', 'animate-pulse-red', 'shadow-xl', 'shadow-red-500/50');
                voiceToggleButton.title = "Presiona para DETENER la grabaci√≥n y enviar";
                stopIcon.classList.remove('hidden');
            } else {
                voiceToggleButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-xl', 'shadow-blue-500/50');
                voiceToggleButton.title = "Presiona para INICIAR la grabaci√≥n";
                micIcon.classList.remove('hidden');
                voiceIcon.classList.remove('speak-active');
            }

            // 5. Contenedor de Respuesta
            const showResponse = responseContainer && appState.dom.responseText.textContent.trim() !== '';
            responseContainer.classList.toggle('hidden', !showResponse);
        }

        /**
         * Maneja errores y restablece el estado.
         * @param {string} message Mensaje de error a mostrar.
         */
        function showCustomError(message) {
            console.error(message);

            // 1. Limpieza de estado
            appState.isLoading = false;
            appState.isRecording = false;
            appState.hasSent = false;
            appState.finalTranscript = "";
            appState.statusMessage = message;

            // 2. Abortar STT y TTS si est√°n activos
            if (appState.recognition) {
                try {
                    appState.recognition.abort();
                } catch (e) { }
            }
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            appState.isSpeaking = false;

            // 3. Limpiar respuesta de texto
            appState.dom.responseText.textContent = '';


            // 4. Actualizar UI
            updateUI();
        }

        /**
         * Cancela la s√≠ntesis de voz y restablece el estado de la UI a la espera.
         */
        function stopSpeaking() {
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            appState.isSpeaking = false;
            appState.finalTranscript = "";
            appState.transcriptionPreview = "";
            appState.hasSent = false;
            appState.statusMessage = "Asesor√≠a interrumpida. Presiona el micr√≥fono para INICIAR una nueva consulta.";
            updateUI();
        }

        /**
         * Utiliza la API de S√≠ntesis de Voz del navegador para leer el texto.
         * @param {string} text El texto a leer.
         */
        function speakText(text) {
            if ('speechSynthesis' in window) {
                // Cancelar cualquier discurso previo
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }

                // Obtener la voz preferida (masculina/alternativa)
                const selectedVoice = getSpanishPreferredVoice();

                // Configuraci√≥n de la voz
                const utterance = new SpeechSynthesisUtterance(text);

                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    // Es importante establecer lang a la lengua real de la voz para mejor calidad
                    utterance.lang = selectedVoice.lang;
                    console.log(`TTS: Usando voz seleccionada: ${selectedVoice.name} (${selectedVoice.lang})`);
                } else {
                    // Fallback si no hay voces espec√≠ficas, usa el idioma gen√©rico
                    utterance.lang = 'es-ES';
                    console.log("TTS: Usando configuraci√≥n de idioma gen√©rica (es-ES).");
                }


                appState.utterance = utterance;

                // Eventos de inicio y fin
                utterance.onstart = () => {
                    appState.isSpeaking = true;
                    appState.statusMessage = "üîä El Asesor IA est√° hablando. Presiona el bot√≥n para INTERRUMPIR.";
                    updateUI();
                };

                utterance.onend = () => {
                    // Solo si termina naturalmente y no fue por cancel
                    if (appState.isSpeaking) {
                        appState.isSpeaking = false;
                        appState.statusMessage = "‚úÖ Asesor√≠a finalizada. Presiona el micr√≥fono para otra consulta.";
                        appState.finalTranscript = ""; // Limpiar despu√©s de la respuesta completa
                        updateUI();
                    }
                };

                utterance.onerror = (event) => {
                    console.error('Error de SpeechSynthesis:', event.error);
                    showCustomError("‚ö†Ô∏è Error en la S√≠ntesis de Voz del navegador.");
                };

                // Iniciar la lectura
                window.speechSynthesis.speak(utterance);

            } else {
                showCustomError("‚ö†Ô∏è S√≠ntesis de Voz (TTS) no compatible con este navegador.");
            }
        }

        /**
         * L√≥gica para enviar la consulta de TEXTO al backend.
         * @param {string} textToSend El texto final transcrito.
         */
        async function sendTextQuery(textToSend) {
            const cleanedText = textToSend.trim();
            if (!cleanedText || appState.hasSent) {
                if (!cleanedText && !appState.isLoading) showCustomError("‚ö†Ô∏è No se detect√≥ ninguna consulta de voz v√°lida.");
                return;
            }

            appState.hasSent = true;
            appState.isLoading = true;
            appState.isRecording = false;
            appState.statusMessage = "‚úÖ Transcripci√≥n capturada. Enviando al Asesor IA...";
            appState.dom.responseText.textContent = ''; // Limpiar respuesta anterior
            updateUI();

            try {
                // 1. Env√≠o de la consulta de texto
                const response = await fetch(TEXT_QUERY_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query_text: cleanedText,
                        username: appState.username,
                    }),
                });

                if (!response.ok) {
                    let errorDetails = `Error del servidor (Status: ${response.status}).`;
                    try {
                        const errorJson = await response.json();
                        errorDetails = errorJson.message || JSON.stringify(errorJson);
                    } catch { }
                    throw new Error(errorDetails);
                }

                // 2. Esperamos una respuesta JSON con el texto
                const responseJson = await response.json();
                const aiResponseText = responseJson[RESPONSE_TEXT_FIELD];

                if (!aiResponseText || typeof aiResponseText !== 'string') {
                    throw new Error("Respuesta de texto de la IA no v√°lida o vac√≠a.");
                }

                // 3. Mostrar Texto en la UI
                appState.dom.responseText.textContent = aiResponseText;

                // 4. Iniciar S√≠ntesis de Voz
                appState.isLoading = false;
                appState.statusMessage = "Respuesta recibida. Iniciando s√≠ntesis de voz...";
                updateUI();
                speakText(aiResponseText);

            } catch (error) {
                console.error("Error en la consulta al backend:", error.message);
                showCustomError(`‚ùå Error en la consulta: ${error.message}.`);
            } finally {
                // El estado 'isLoading' se desactiva antes de 'speakText'
                // El estado 'isSpeaking' se desactiva en 'utterance.onend'
                // Si hay un error, 'showCustomError' maneja el cleanup.
            }
        }


        /**
         * Inicializa la Web Speech API y sus eventos.
         */
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                showCustomError("‚ö†Ô∏è Navegador no compatible con Web Speech API para STT.");
                return;
            }

            const recognition = appState.recognition || new webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'es-ES';
            appState.recognition = recognition;

            appState.finalTranscript = "";

            recognition.onresult = (event) => {
                let finalTranscriptPart = '';
                let interimTranscriptPart = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscriptPart += event.results[i][0].transcript;
                    } else {
                        interimTranscriptPart += event.results[i][0].transcript;
                    }
                }

                if (finalTranscriptPart) {
                    // Solo agregamos un espacio si ya hay texto final acumulado
                    if (appState.finalTranscript.length > 0) {
                        appState.finalTranscript += ' ';
                    }
                    appState.finalTranscript += finalTranscriptPart;
                }

                appState.transcriptionPreview = appState.finalTranscript + interimTranscriptPart;
                updateUI();
            };

            recognition.onerror = (event) => {
                if (appState.hasSent) return;

                if (event.error === 'not-allowed') {
                    showCustomError("‚ùå Acceso al micr√≥fono bloqueado. Debes permitirlo en la configuraci√≥n.");
                } else if (event.error !== 'no-speech' && event.error !== 'audio-capture') {
                    showCustomError(`‚ùå Error de STT (${event.error}). Intenta de nuevo.`);
                }
                appState.isRecording = false;
                updateUI();
            };

            recognition.onend = () => {
                if (!appState.hasSent && !appState.isLoading && !appState.isSpeaking) {
                    appState.isRecording = false;
                    appState.statusMessage = "Grabaci√≥n detenida. Presiona para empezar de nuevo.";
                    updateUI();
                }
            };

            appState.dom.voiceToggleButton.disabled = appState.isLoading || !appState.username;
            updateUI();
        }

        /**
         * L√≥gica principal para iniciar, detener la grabaci√≥n o interrumpir el TTS.
         */
        function handleVoiceToggle() {
            if (!appState.recognition || appState.isLoading) return;
            if (!appState.username) {
                showCustomError("‚ùå Por favor, ingresa tu nombre antes de comenzar.");
                return;
            }

            if (appState.isSpeaking) {
                // CASO NUEVO: Interrumpir TTS y volver a estado de espera
                console.log("Interrumpiendo TTS...");
                stopSpeaking();

            } else if (appState.isRecording) {
                // Caso 1: Estaba grabando -> Detener y ENVIAR
                appState.isRecording = false;
                appState.statusMessage = "Deteniendo, esperando transcripci√≥n final...";
                updateUI();

                // Abortar para capturar la transcripci√≥n final y liberar el micr√≥fono
                try {
                    appState.recognition.abort();
                } catch (e) {
                    console.warn("Error al llamar a recognition.abort().", e);
                }

                // CRUCIAL: Retraso para capturar el √∫ltimo onresult final
                setTimeout(() => {
                    let textToSend = appState.finalTranscript.trim();

                    if (!textToSend && appState.transcriptionPreview.trim()) {
                        // Fallback por si la API no actualiz√≥ finalTranscript a tiempo
                        textToSend = appState.transcriptionPreview.trim();
                        console.log("Usando texto de fallback (Vista Previa) para enviar:", textToSend);
                    }

                    if (textToSend) {
                        sendTextQuery(textToSend);
                    } else {
                        showCustomError("‚ö†Ô∏è No se detect√≥ ninguna consulta de voz v√°lida.");
                    }

                    appState.transcriptionPreview = "";
                    updateUI();
                }, 100);


            } else {
                // Caso 2: No estaba grabando -> Iniciar grabaci√≥n

                // Limpiar estados anteriores
                if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
                appState.isSpeaking = false;
                appState.transcriptionPreview = "";
                appState.dom.responseText.textContent = ''; // Limpiar texto de respuesta
                appState.hasSent = false;
                appState.finalTranscript = "";

                try {
                    // Abortar cualquier estado anterior antes de empezar (limpia el motor STT)
                    if (appState.recognition) appState.recognition.abort();

                    appState.recognition.start();
                    appState.isRecording = true;
                    appState.statusMessage = "üî¥ Grabando Audio. Presiona de nuevo para DETENER y enviar.";
                    updateUI();
                } catch (error) {
                    if (error.name !== 'InvalidStateError') {
                        showCustomError(`‚ùå Error al iniciar grabaci√≥n: ${error.message}`);
                    }
                }
            }
        }

        /**
         * Maneja el env√≠o del formulario de nombre de usuario.
         */
        function handleNameSubmit(event) {
            event.preventDefault();
            const input = appState.dom.nameInput.value.trim();
            if (input) {
                appState.username = input;
                localStorage.setItem('v2v_username', input);
                appState.statusMessage = "Listo. Presiona el micr√≥fono para INICIAR la consulta.";
                updateUI();
            }
        }

        /**
         * Carga las voces TTS de forma as√≠ncrona.
         */
        function loadTTSVoices() {
            // Aseg√∫rate de que las voces est√©n cargadas. A veces se necesita un retraso.
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                appState.ttsVoices = voices;
                updateUI();
            } else if (window.speechSynthesis.onvoiceschanged !== null) {
                window.speechSynthesis.onvoiceschanged = () => {
                    appState.ttsVoices = window.speechSynthesis.getVoices();
                    updateUI();
                };
            }
        }

        /**
         * Inicializa la aplicaci√≥n: obtiene referencias DOM y carga el estado inicial.
         */
        function initializeApp() {
            // 1. Obtener Referencias DOM
            appState.dom.statusArea = document.getElementById('statusArea');
            appState.dom.statusMessage = document.getElementById('statusMessage');
            appState.dom.transcriptionBox = document.getElementById('transcriptionBox');
            appState.dom.transcriptionPreview = document.getElementById('transcriptionPreview');
            appState.dom.voiceToggleButton = document.getElementById('voiceToggleButton');
            appState.dom.micIcon = document.getElementById('micIcon');
            appState.dom.loaderIcon = document.getElementById('loaderIcon');
            appState.dom.stopIcon = document.getElementById('stopIcon');

            // Referencias para la nueva respuesta de texto/TTS
            appState.dom.responseContainer = document.getElementById('responseContainer');
            appState.dom.responseText = document.getElementById('responseText');
            appState.dom.voiceIcon = document.getElementById('voiceIcon');

            appState.dom.nameForm = document.getElementById('nameForm');
            appState.dom.nameInput = document.getElementById('nameInput');
            appState.dom.usernameDisplay = document.getElementById('usernameDisplay');
            appState.dom.currentUsername = document.getElementById('currentUsername');

            // 2. Cargar Estado Inicial
            const storedName = localStorage.getItem('v2v_username');
            if (storedName) {
                appState.username = storedName;
                appState.statusMessage = "Listo. Presiona el micr√≥fono para INICIAR la consulta.";
            } else {
                appState.statusMessage = "Por favor, ingresa tu nombre para comenzar.";
            }

            // 3. Inicializar Speech Recognition y cargar voces TTS
            initSpeechRecognition();
            loadTTSVoices(); // Intenta cargar las voces

            // 4. Configurar Event Listeners
            appState.dom.voiceToggleButton.addEventListener('click', handleVoiceToggle);
            appState.dom.nameForm.addEventListener('submit', handleNameSubmit);

            // 5. Renderizado Inicial
            updateUI();

            // Inicializar Lucide Icons despu√©s de que el DOM est√© listo
            lucide.createIcons();
        }

        // Ejecutar la inicializaci√≥n cuando el DOM est√© completamente cargado
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Agregamos un listener para cancelar el TTS si el usuario recarga
        window.addEventListener('beforeunload', () => {
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
        });

    </script>

</body>

</html>